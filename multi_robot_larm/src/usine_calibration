#!/usr/bin/python3
import time
import rclpy
from rclpy.node import Node
from rclpy.context import Context
from rclpy.executors import MultiThreadedExecutor
from random import random
from multi_robot_larm.msg import Bid, Package
from geometry_msgs.msg import PoseStamped
import yaml
import sys
import argparse

# ==========================================================
# ROS NODE
# ==========================================================

class FactoryNode(Node):
    def __init__(
        self,
        domain_id: int,
        messages: list,
        usine,
        pub_freq: float,
    ):
        context = Context()
        context.init(domain_id=domain_id)

        super().__init__(f"usine_{domain_id}", context=context)
        
        self.domain_id = domain_id
        self.messages = messages
        self.index = 0
        self.usine = usine

        self.points_pub = self.create_publisher(Package, "start_bid", 10)
        self.result_pub = self.create_publisher(Package, "win_bid", 10)

        self.create_subscription(
            Bid,
            "bid",
            self.on_enchere_received,
            10
        )

        self.create_timer(pub_freq, self.publish_point)

    def publish_point(self):
        if self.index >= len(self.messages):
            return
    
        colis_id, arrival, delivery = self.messages[self.index]

        msg = Package()
        msg.id = colis_id
        msg.departure = delivery
        msg.arrival= arrival
        #msg.data = f"{colis_id}, {arrival}, {delivery}"
        
        self.points_pub.publish(msg)

        self.usine.start_auction(colis_id, arrival, delivery)

        self.get_logger().info(f"[POINTS] {msg}")
        self.index += 1

    def on_enchere_received(self, msg: Bid):
        try:
            colis_id, ros_id, price = msg.id, msg.ros_domain_id, msg.cost
            self.usine.on_bid(
                int(colis_id),
                int(ros_id),
                float(price)
            )
        except ValueError:
            self.get_logger().error(f"Message enchere invalide: {msg}")

    def publish_result(self, data: Package): 
        msg = data
        self.result_pub.publish(msg)
        self.get_logger().info(f"[RESULT] {data}")

    


# ==========================================================
# USINE (LOGIQUE MÉTIER)
# ==========================================================

class Usine:
    def __init__(self, auction_duration=5.0):
        self.auction_duration = auction_duration
        self.auctions = {}
        self.result_publishers = {}

    def start_auction(self, colis_id, arrival, delivery):
        if colis_id in self.auctions:
            return

        self.auctions[colis_id] = {
            "start_time": time.time(),
            "arrival": arrival,
            "delivery": delivery,
            "offers": [],
            "closed": False
        }

        print(f"[USINE] Enchère démarrée pour colis {colis_id}")

    def on_bid(self, colis_id, ros_id, price):
        if colis_id not in self.auctions:
            return

        auction = self.auctions[colis_id]
        if auction["closed"]:
            return

        auction["offers"].append((ros_id, price))

    def check_auctions(self):
        now = time.time()

        for colis_id, auction in self.auctions.items():
            if auction["closed"]:
                continue

            if now - auction["start_time"] >= self.auction_duration:
                self.close_auction(colis_id)

    def close_auction(self, colis_id):
        auction = self.auctions[colis_id]
        auction["closed"] = True

        if not auction["offers"]:
            print(f"[USINE] Aucune enchère pour colis {colis_id}")
            return

        winner_ros, best_price = min(
            auction["offers"], key=lambda x: x[1]
        )

        print(f"[USINE] Enchère finite. Enchères récues : ")
        for auction_print in auction["offers"] :
            print(f"[USINE] {auction_print}")

        print(
            f"[USINE] Colis {colis_id} attribué à robot {winner_ros} "
            f"pour {best_price}"
        )

        self.publish_result(colis_id, auction, winner_ros)

    def publish_result(self, colis_id, auction, winner_ros):
        d = auction["delivery"]
        a = auction["arrival"]
        msg = Package()
        msg.id = colis_id
        msg.departure = a
        msg.arrival = d
        pub = self.result_publishers[winner_ros]
        pub(msg)
    
def generate_packages(input_file, n=20):
        #print(input_file)
        with open(input_file) as stream:
            try:
                data = yaml.safe_load(stream)
                #print(data.get('points'))
                deliveries=[]
                arrivals = []
                for point in data.get('points'):
                    if 'Arrival' in point.get('id'):
                        #print("--------------")
                        #print(f"point :{point}")
                        pointTMP = PoseStamped()
                        pointTMP.pose.position.x = float(point.get('x'))
                        pointTMP.pose.position.y = float(point.get('y'))
                        pointTMP.pose.position.z = float(point.get('z'))
                        pointTMP.pose.orientation.w = 1.0
                        arrivals.append(pointTMP)
                        #print(f"arrivals : {arrivals}")
                        #print("--------------")
                    elif 'Deposit' in point.get('id'):
                        #print("--------------")
                        #print(f"point :{point}")
                        pointTMP1 = PoseStamped()
                        pointTMP1.pose.position.x = float(point.get('x'))
                        pointTMP1.pose.position.y = float(point.get('y'))
                        pointTMP1.pose.position.z = float(point.get('z'))
                        pointTMP1.pose.orientation.w = 1.0
                        deliveries.append(pointTMP1)
                        #print(f"deliveries : {deliveries}")
                        #print("--------------")

                '''#for 
                pickup_A = PoseStamped()
                pickup_A.pose.position.x = 1.73
                pickup_A.pose.position.y = -0.46
                pickup_A.pose.position.z = 0.0
                #"1.73 -0.46 0.0"
                #pickup_B = "1.66 0.60 0.0"

                pickup_B = PoseStamped()
                pickup_B.pose.position.x = 1.66
                pickup_B.pose.position.y = 0.6
                pickup_B.pose.position.z = 0.0

                delivery1 = PoseStamped()
                delivery1.pose.position.x = -5.3
                delivery1.pose.position.y = 0.84
                delivery1.pose.position.z = 0.0

                delivery2 = PoseStamped()
                delivery2.pose.position.x = -0.5
                delivery2.pose.position.y = -2.15
                delivery2.pose.position.z = 0.0

                delivery3 = PoseStamped()
                delivery3.pose.position.x = -4.6
                delivery3.pose.position.y = -2.15
                delivery3.pose.position.z = 0.0'''

                '''deliveries = [
                    "-5.3 0.84 0.0",
                    "-0.5 -2.15 0.0",
                    "-4.6 -2.47 0.0",
                ]'''
                #deliveries=[delivery1,delivery2,delivery3]

                messages = []
                #print(f"deliveries : {deliveries}")
                #print(f"arrivals : {arrivals}")
                for i in range(n):
                    #pickup_A if random() < 0.5 else pickup_B
                    arrival = arrivals[int(random() * len(arrivals))]
                    delivery = deliveries[int(random() * len(deliveries))]
                    messages.append((i, arrival, delivery))

                return messages
            except yaml.YAMLError as exc:
                print(exc)
        


# ==========================================================
# DATA GENERATION
# ==========================================================


# ==========================================================
# MAIN
# ==========================================================

def main():
    print(sys.argv)

    parser = argparse.ArgumentParser()
    parser.add_argument("--input-file" , type=str)
    args = parser.parse_args()
    print(args)
    try:
        print(args.input_file)
    except SyntaxError:
        print("You need to give an input-file for the points")

    rclpy.init()

    usine = Usine(auction_duration=3.0)
    messages = generate_packages(args.input_file, 30)

    #print(messages)
    parserROS = argparse.ArgumentParser()
    parserROS.add_argument("--domain-file" , type=str)
    argsROS = parserROS.parse_args()
    try:
        print(argsROS.input_file)
    except SyntaxError:
        print("You need to give an ROS-file for the ROS_DOMAIN_ID of your robots")

    nodes = []

    for ROS_DOMAIN_ID in argsROS.input_file.get('robots'):
        nodes.append(FactoryNode(int(ROS_DOMAIN_ID.get('ROS_DOMAIN_ID')), messages, usine, 6.0))
    '''nodes = [
        FactoryNode(44, messages, usine, 6.0),
        FactoryNode(40, messages, usine, 6.0),
    ]'''

    executor = MultiThreadedExecutor()
    for node in nodes:
        executor.add_node(node)
        usine.result_publishers[node.domain_id] = node.publish_result

    nodes[0].create_timer(0.2, usine.check_auctions)

    try:
        executor.spin()
    finally:
        for node in nodes:
            node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()