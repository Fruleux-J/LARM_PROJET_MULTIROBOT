#!/usr/bin/python3
import time
import rclpy
from rclpy.node import Node
from rclpy.context import Context
from rclpy.executors import MultiThreadedExecutor
from random import random
from multi_robot_larm.msg import Bid, Package, Pose
from geometry_msgs.msg import PoseStamped

# ==========================================================
# USINE (LOGIQUE MÉTIER)
# General class that manage the packages and works as a bridge between the differents ros_domain_ids. 
# ==========================================================

class Usine:

    def __init__(self, auction_duration=5.0):
        self.auction_duration = auction_duration
        self.auctions = {}
        self.result_publishers = {}
        self.currently_positions = {}

    def start_auction(self, colis_id, arrival, delivery):                   # Function to create a new auction.
        if colis_id in self.auctions:
            return

        self.auctions[colis_id] = {
            "start_time": time.time(),
            "arrival": arrival,
            "delivery": delivery,
            "offers": [],
            "closed": False
        }

        print(f"\n\n[USINE] Enchère démarrée pour colis {colis_id}")

    def on_bid(self, colis_id, ros_id, price):                              # Function to check if a new bid has arrived.
        if colis_id not in self.auctions:
            return

        auction = self.auctions[colis_id]
        if auction["closed"]:
            return

        auction["offers"].append((ros_id, price))

    def check_auctions(self):                                               # Function to check if the actuion has finished according its timeout.
        now = time.time()

        for colis_id, auction in self.auctions.items():
            if auction["closed"]:
                continue

            if now - auction["start_time"] >= self.auction_duration:
                self.close_auction(colis_id)

    def close_auction(self, colis_id):                                      # Function to close the auction and send package information to the winner. 
        auction = self.auctions[colis_id]
        auction["closed"] = True

        if not auction["offers"]:
            print(f"[USINE] Aucune enchère pour colis {colis_id}")
            return

        winner_ros, best_price = min(
            auction["offers"], key=lambda x: x[1]
        )

        print(f"[USINE] Enchère finite. Enchères récues : ")
        for auction_print in auction["offers"] :
            print(f"[USINE] {auction_print}")

        print(
            f"[USINE] Colis {colis_id} attribué à robot {winner_ros} "
            f"pour {best_price}"
        )

        self.publish_result(colis_id, auction, winner_ros)

    def publish_result(self, colis_id, auction, winner_ros):                # Construct the package message for the winner. 
        d = auction["delivery"]
        a = auction["arrival"]
        msg = Package()
        msg.id = colis_id
        msg.departure = d
        msg.arrival = a
        pub = self.result_publishers[winner_ros]
        pub(msg)

# ==========================================================
# ROS NODE
# Class used to connect the general factory to each ros_domain_id.
# ==========================================================

class FactoryNode(Node):
    def __init__(
        self,
        domain_id: int,
        messages: list,
        usine,
        pub_freq: float,
    ):
        # Node creation.
        context = Context()
        context.init(domain_id=domain_id)

        super().__init__(f"usine_{domain_id}", context=context)

        self.domain_id = domain_id
        self.messages = messages
        self.index = 0
        self.usine = usine

        # Publishers.
        self.points_pub = self.create_publisher(Package, "start_bid", 10)
        self.result_pub = self.create_publisher(Package, "win_bid", 10)
        self.colission_pub = self.create_publisher(Pose, "collision", 10)
        

        # Subscribers.
        self.create_subscription(
            Bid,
            "bid",
            self.on_enchere_received,
            10
        )

        self.create_subscription(
            Pose,
            "robot_pose",
            self.update_actual_pose,
            10
        )

        # Timers.
        self.create_timer(pub_freq, self.publish_point)
        self.create_timer(0.1,self.publish_collision)

    # Not used function. Designed to avoid the collisions. 
    def publish_collision(self):
        msg = Pose()
        for ros_id, pose in self.usine.currently_positions.items():
            msg.ros_domain_id
            msg.pose = pose
            self.colission_pub.publish(msg)

    # Receive the robot position and update it in the usine dictionary. 
    def update_actual_pose(self, msg : Pose) : 
        try:
            ros_id, pose = msg.ros_domain_id, msg.pose
            self.usine.currently_positions[ros_id] = pose
        except ValueError:
            self.get_logger().error(f"Pose invalide: {msg}")
        
    # Start the auction timer and send the new package to the start_bid topic.
    def publish_point(self):
        if self.index >= len(self.messages):
            return
    
        colis_id, arrival, delivery = self.messages[self.index]

        msg = Package()
        msg.id = colis_id
        msg.departure =arrival
        msg.arrival= delivery
        
        self.points_pub.publish(msg)

        self.usine.start_auction(colis_id, arrival, delivery)

        self.get_logger().info(f"[POINTS] {msg}")
        self.index += 1

    # Read the bid from the robot and upload to the usine dictionary. 
    def on_enchere_received(self, msg: Bid):
        try:
            colis_id, ros_id, price = msg.id, msg.ros_domain_id, msg.cost
            self.usine.on_bid(
                int(colis_id),
                int(ros_id),
                float(price)
            )
        except ValueError:
            self.get_logger().error(f"Message enchere invalide: {msg}")


    def publish_result(self, data: Package): 
        msg = data
        self.result_pub.publish(msg)
        self.get_logger().info(f"[RESULT] {data}")

# ==========================================================
# DATA GENERATION
# ==========================================================

# Function to generate randomly packages from the scenario used.
def generate_packages(n=20):
    
    pickup_A = PoseStamped()
    pickup_A.pose.position.x = 1.73
    pickup_A.pose.position.y = -0.46
    pickup_A.pose.position.z = 0.0

    pickup_B = PoseStamped()
    pickup_B.pose.position.x = 1.66
    pickup_B.pose.position.y = 0.6
    pickup_B.pose.position.z = 0.0

    delivery1 = PoseStamped()
    delivery1.pose.position.x = -5.3
    delivery1.pose.position.y = 0.84
    delivery1.pose.position.z = 0.0

    delivery2 = PoseStamped()
    delivery2.pose.position.x = -0.5
    delivery2.pose.position.y = -2.15
    delivery2.pose.position.z = 0.0

    delivery3 = PoseStamped()
    delivery3.pose.position.x = -4.6
    delivery3.pose.position.y = -2.15
    delivery3.pose.position.z = 0.0

    '''deliveries = [
        "-5.3 0.84 0.0",
        "-0.5 -2.15 0.0",
        "-4.6 -2.47 0.0",
    ]'''
    deliveries=[delivery1,delivery2,delivery3]

    messages = []

    for i in range(n):
        arrival = pickup_A if random() < 0.5 else pickup_B
        delivery = deliveries[int(random() * len(deliveries))]
        messages.append((i, arrival, delivery))

    return messages


# ==========================================================
# MAIN
# ==========================================================

def main():
    rclpy.init()

    usine = Usine(auction_duration=3.0)
    messages = generate_packages(30)

    nodes = [
        FactoryNode(44, messages, usine, 6.0),
        FactoryNode(40, messages, usine, 6.0),
    ]

    executor = MultiThreadedExecutor()
    for node in nodes:
        executor.add_node(node)
        usine.result_publishers[node.domain_id] = node.publish_result

    nodes[0].create_timer(0.2, usine.check_auctions)

    try:
        executor.spin()
    finally:
        for node in nodes:
            node.destroy_node()
        rclpy.shutdown()


if __name__ == "__main__":
    main()
